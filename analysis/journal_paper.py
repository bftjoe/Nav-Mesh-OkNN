import pandas as pd
import numpy as np
from utilities import alias
from utilities import plot_graph
from utilities import gen_xy
import matplotlib.pyplot as plt

def nn_time_by_vnum(DF, ylim=None, xlim=None, saveto=None, limit=10, size=500, xscale='log', yscale='log'):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  # df.cost_fi = df.cost_ki0 / df.cost_fi
  # df.cost_ffp = df.cost_ki0 / df.cost_ffp
  # df.cost_ki = df.cost_ki0 / df.cost_ki
  # df.cost_hi = df.cost_ki0 / df.cost_hi
  # df.gen_ki0 = (df.gen_ki0 / size).astype(int)
  # vnum = df.vertices.min()
  df.vnum = (df.vnum / size).astype(int)
  xs[0], ys[0] = gen_xy(df, 'vnum', 'cost_fc', limit=limit)
  algos.append(alias['fence nn'])

  xs[1], ys[1] = gen_xy(df, 'vnum', 'cost_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[2], ys[2] = gen_xy(df, 'vnum', 'cost_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[3], ys[3] = gen_xy(df, 'vnum', 'cost_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[4], ys[4] = gen_xy(df, 'vnum', 'cost_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  # xs[5], ys[5] = gen_xy(df, 'pts', 'cost_edbt', limit=limit)
  # algos.append('LVG')

  for i in xs.keys():
    xs[i] = [v * size for v in xs[i]]
    ys[i] = [v / 1000.0 for v in ys[i]]

  # plot_graph('Nodes generated by h0', 'Speedup vs h0', list(xs.values()), list(ys.values()), algos,
  #     ylim=ylim, saveto=saveto, xscale='log')

  plot_graph('vertices on path', 'time(ms) log10', list(xs.values()), list(ys.values()), algos,
      ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, yscale=yscale)

def nn_gen_by_vnum(DF, ylim=None, xlim=None, saveto=None, limit=10, size=500, xscale='log', yscale='log'):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  df.vnum = (df.vnum / size).astype(int)
  xs[0], ys[0] = gen_xy(df, 'vnum', 'gen_fc', limit=limit)
  algos.append(alias['fence nn'])

  xs[1], ys[1] = gen_xy(df, 'vnum', 'gen_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[2], ys[2] = gen_xy(df, 'vnum', 'gen_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[3], ys[3] = gen_xy(df, 'vnum', 'gen_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[4], ys[4] = gen_xy(df, 'vnum', 'gen_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  # xs[5], ys[5] = gen_xy(df, 'pts', 'cost_edbt', limit=limit)
  # algos.append('LVG')

  for i in xs.keys():
    xs[i] = [v * size for v in xs[i]]
    ys[i] = [v / 1000.0 for v in ys[i]]

  # plot_graph('Nodes generated by h0', 'Speedup vs h0', list(xs.values()), list(ys.values()), algos,
  #     ylim=ylim, saveto=saveto, xscale='log')

  plot_graph('vertices on path', '\#gen log10', list(xs.values()), list(ys.values()), algos,
      ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, yscale=yscale)



def nn_time_by_dense(DF, ylim=None, xlim=None, saveto=None, limit=10, size=500, xscale='log', yscale='log'):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  vnum = df.vertices.min()
  xs[0], ys[0] = gen_xy(df, 'pts', 'cost_fc', limit=limit)
  algos.append(alias['fence nn'])

  xs[1], ys[1] = gen_xy(df, 'pts', 'cost_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[2], ys[2] = gen_xy(df, 'pts', 'cost_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'pts', 'cost_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[4], ys[4] = gen_xy(df, 'pts', 'cost_fi', limit=limit)
  algos.append(alias['fence heuristic'])
  for i in xs.keys():
    xs[i] = [v / float(vnum) for v in xs[i]]
    ys[i] = [v / 1000.0 for v in ys[i]]

  # plot_graph('Nodes generated by h0', 'Speedup vs h0', list(xs.values()), list(ys.values()), algos,
  #     ylim=ylim, saveto=saveto, xscale='log')

  xticks = ([0.0001, 0.001, 0.01, 0.1], ["0.01\%", "0.1\%", "1\%", "10\%"])
  plot_graph('target density', 'time(ms) log10', list(xs.values()), list(ys.values()), algos,
      ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, yscale=yscale, xticks=xticks)


def nn_gen_by_dense(DF, ylim=None, xlim=None, saveto=None, limit=10, size=500, xscale='log', yscale='log'):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  vnum = df.vertices.min()
  xs[0], ys[0] = gen_xy(df, 'pts', 'gen_fc', limit=limit)
  algos.append(alias['fence nn'])

  xs[1], ys[1] = gen_xy(df, 'pts', 'gen_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[2], ys[2] = gen_xy(df, 'pts', 'gen_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'pts', 'gen_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[4], ys[4] = gen_xy(df, 'pts', 'gen_fi', limit=limit)
  algos.append(alias['fence heuristic'])
  for i in xs.keys():
    xs[i] = [v / float(vnum) for v in xs[i]]

  # plot_graph('Nodes generated by h0', 'Speedup vs h0', list(xs.values()), list(ys.values()), algos,
  #     ylim=ylim, saveto=saveto, xscale='log')

  xticks = ([0.0001, 0.001, 0.01, 0.1], ["0.01\%", "0.1\%", "1\%", "10\%"])
  plot_graph('target density', '\#gen log10', list(xs.values()), list(ys.values()), algos,
      ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, yscale=yscale, xticks=xticks)



def cluster_improve_time(DF, size=100, limit=1, ylim=None, xlim=None, saveto=None, xscale='log'):
  df = DF.copy()
  df.gen_ki = (df.gen_ki / float(size)).astype(int)
  df['imp_hi'] = df.cost_ki / df.cost_hi
  df['imp_poly'] = df.cost_ki / df.cost_ffp
  df['imp_fi'] = df.cost_ki / df.cost_fi
  df['imp_ki'] = df.cost_ki / df.cost_ki
  xs = {}
  ys = {}
  algos = []

  xs[0], ys[0] = gen_xy(df, 'gen_ki', 'imp_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  xs[1], ys[1] = gen_xy(df, 'gen_ki', 'imp_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'gen_ki', 'imp_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'gen_ki', 'imp_poly', limit=limit)
  algos.append(alias['rePolyanya'])

  for k in xs.keys():
    xs[k] = [v * size for v in xs[k]]
      
  plot_graph('Nodes generated by h$_v$', 'speed up vs h$_v$', list(xs.values()), list(ys.values()), algos, 
             ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, loc='in')

def cluster_improve_gen(DF, size=100, limit=1, ylim=None, xlim=None, saveto=None, xscale='log'):
  df = DF.copy()
  df['imp_hi'] = df.gen_ki / df.gen_hi
  df['imp_poly'] = df.gen_ki / df.gen_ffp
  df['imp_fi'] = df.gen_ki / df.gen_fi
  df['imp_ki'] = df.gen_ki / df.gen_ki
  df.gen_ki = (df.gen_ki / float(size)).astype(int)
  xs = {}
  ys = {}
  algos = []

  xs[0], ys[0] = gen_xy(df, 'gen_ki', 'imp_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  xs[1], ys[1] = gen_xy(df, 'gen_ki', 'imp_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'gen_ki', 'imp_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'gen_ki', 'imp_poly', limit=limit)
  algos.append(alias['rePolyanya'])

  for k in xs.keys():
    xs[k] = [v * size for v in xs[k]]
      
  plot_graph('Nodes generated by h$_v$', 'Reduced gen vs h$_v$', list(xs.values()), list(ys.values()), algos, 
             ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, loc='in')


def cluster_false_hit(DF, size=100, limit=1, ylim=None, xlim=None, saveto=None, xscale='log', yscale='linear'):
  df = DF.copy()
  df.gen_ki = (df.gen_ki / float(size)).astype(int)
  df['fh_poly'] = df.tot_hit - df.k
  xs = {}
  ys = {}
  algos = []

  xs[3], ys[3] = gen_xy(df, 'gen_ki', 'fh_poly', limit=limit)
  algos.append(alias['rePolyanya'])

  for k in xs.keys():
    xs[k] = [v * size for v in xs[k]]
      
  plot_graph('Nodes generated by h$_v$', 'false hit', list(xs.values()), list(ys.values()), algos, 
             ylim=ylim, xlim=xlim, saveto=saveto, xscale=xscale, yscale=yscale, loc='in')

def fence_time(DF, limit=1, size=1, saveto=None):
    xs = {}
    ys = {}
    algos = []
    df = DF.copy()
    df.pts = (df.pts / size).astype(int)
    for k in xs.keys():
      xs[k] = [v * size for v in xs[k]]
    xs[0], ys[0] = gen_xy(df, 'pts', 'cost', limit=limit)
    algos.append('ratio')
    plot_graph('target number', 'time(ms) log10', list(xs.values()), list(ys.values()), algos,
        yscale='log')


def vary_k(DF, saveto=None, xscale='log', limit=10, xlim=None, yscale=None, ylim=None):
  # dense: time
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []

  xs[0], ys[0] = gen_xy(df, 'k', 'cost_ffp', limit=limit)
  algos.append(alias['rePolyanya'])
  print (max(ys[0]) / min(ys[0]))

  xs[1], ys[1] = gen_xy(df, 'k', 'cost_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'k', 'cost_hi', limit=limit)
  algos.append(alias['target heuristic'])

  if (df.cost_edbt.max() > 0):
    df['cost_edbt'] = df.cost_edbt.clip(0, 1e6)
    xs[3], ys[3] = gen_xy(df, 'k', 'cost_edbt', limit=limit)
    algos.append('LVG')

  xs[4], ys[4] = gen_xy(df, 'k', 'cost_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  for k in xs.keys():
      xs[k] = [v for v in xs[k]]
      ys[k] = [v / 1000 for v in ys[k]]
      
  plot_graph('k', 'time(ms) (log10)', list(xs.values()), list(ys.values()), algos,
             ylim=ylim, saveto=saveto, xscale=xscale, xlim=xlim, yscale=yscale)

def vary_k_gen(DF, ylim=None, saveto=None, xscale='log', limit=10, xlim=None, yscale=None):
  # dense: time
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []

  xs[0], ys[0] = gen_xy(df, 'k', 'gen_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[1], ys[1] = gen_xy(df, 'k', 'gen_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'k', 'gen_hi', limit=limit)
  algos.append(alias['target heuristic'])

  if (df.cost_edbt.max() > 0):
    xs[3], ys[3] = gen_xy(df, 'k', 'gen_edbt', limit=limit)
    algos.append('LVG')

  xs[4], ys[4] = gen_xy(df, 'k', 'gen_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  for k in xs.keys():
      xs[k] = [v for v in xs[k]]
      
  plot_graph('k', 'generated (log10)', list(xs.values()), list(ys.values()), algos,
             ylim=ylim, saveto=saveto, xscale=xscale, xlim=xlim, yscale=yscale)




def vary_t(DF, ylim=None, saveto=None, limit=10):
  # sparse: time
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []

  df['cost_edbt'] = df.cost_edbt.clip(0, 1e6)

  xs[0], ys[0] = gen_xy(df, 'pts', 'cost_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  xs[1], ys[1] = gen_xy(df, 'pts', 'cost_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'pts', 'cost_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'pts', 'cost_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[4], ys[4] = gen_xy(df, 'pts', 'cost_edbt', limit=limit)
  algos.append('LVG')

  vnum = df.vertices.min()

  for i in xs.keys():
      xs[i] = [v / float(vnum) for v in xs[i]]
      ys[i] = [v / 1000 for v in ys[i]]
  xticks = ([0.0001, 0.001, 0.01, 0.1], ["0.01\%", "0.1\%", "1\%", "10\%"])
  plot_graph('target density', 'time(ms) (log10)', list(xs.values()), list(ys.values()), algos,
             ylim=ylim, saveto=saveto, xscale='log', xticks=xticks)


def false_hit_desc(ar0, brc, cat, obs):
  ar0['false_hit'] = ar0.tot_hit - ar0.k
  brc['false_hit'] = brc.tot_hit - brc.k
  cat['false_hit'] = cat.tot_hit - cat.k
  obs['false_hit'] = obs.tot_hit - obs.k
  cols = ['mean', 'std', 'min', '25%', '50%', '75%', 'max']
  info = {
      'AR0602SR': [5] + list(ar0.false_hit.describe()[cols]),
      'brc202d': [5] + list(brc.false_hit.describe()[cols]),
      'CatwalkAlley': [5] + list(cat.false_hit.describe()[cols]),
      '9k': [5] + list(obs.false_hit.describe()[cols]),
  }
  df = pd.DataFrame.from_dict(data=info, orient='index', columns=['k'] + cols).sort_index()
  return df

def map_summary():
  cols = ["obstacles", "vertices", "mesh polygons"]
  maps = {
      "AR0602SR": [47, 5504, 5594],
      "brc202d": [75, 4035, 4164],
      "CatwalkAlley": [157, 15301, 15482],
      "9k tiled obstacles": [8385, 109171, 125937]
  }
  df = pd.DataFrame.from_dict(data=maps, orient='index', columns=cols).sort_index()
  return df

def parameter_summary():
  cols = ["Values"]
  paras = {
      "Maps": ["AR0602SR, brc202d, CatwalkAlley, 9k-tiled-obstacles"],
      "$k$": ["1, 5, 10, 25, 50"],
      "Density ($d$)": ["0.0001, 0.001, 0.01, 0.1"],
      "Target distribution": ["uniform, clustered"]
  }
  df = pd.DataFrame.from_dict(data=paras, columns=cols, orient="index")
  return df

def heuristic_summary(DF):
  df = DF.copy()
  df['avg_ht'] = df.hcost / df.hcall
  df['avg_hv'] = df.cost_ki / df.gen_ki
  df['avg_hf'] = df.cost_fi / df.gen_fi
  df['avg_hp'] = df.cost_ffp / df.gen_ffp
  cols = ['mean', 'std', 'min', '25%', '50%', '75%', 'max']
  info = {
      'ht': df.avg_ht.describe()[cols],
      'hv': df.avg_hv.describe()[cols],
      'hf': df.avg_hf.describe()[cols],
      'hp': df.avg_hp.describe()[cols]
  }
  t = pd.DataFrame.from_dict(data=info, columns=cols, orient='index').sort_index()
  return t

def vary_map_time(DF, size=100, limit=1, ylim=None, xlim=None, saveto=None, xscale='log'):
  saveto = './figs/e1_dense_time.png'
  df = DF.copy()
  # df.dist = (df.dist / size).astype(int)
  df.gen_ki = (df.gen_ki / float(size)).astype(int)
  xs = {}
  ys = {}
  algos = []

  xs[0], ys[0] = gen_xy(df, 'gen_ki', 'cost_ffp', limit=limit)
  algos.append(alias['rePolyanya'])

  xs[1], ys[1] = gen_xy(df, 'gen_ki', 'cost_ki', limit=limit)
  algos.append(alias['interval heuristic'])

  xs[2], ys[2] = gen_xy(df, 'gen_ki', 'cost_hi', limit=limit)
  algos.append(alias['target heuristic'])

  xs[3], ys[3] = gen_xy(df, 'gen_ki', 'cost_fi', limit=limit)
  algos.append(alias['fence heuristic'])

  for k in xs.keys():
      xs[k] = [v * size for v in xs[k]]
      ys[k] = [v / 1000 for v in ys[k]]
#     ys[k] = np.log10(ys[k])
      
  plot_graph('Nodes generated by hv', 'time(ms) (log10)', list(xs.values()), list(ys.values()), algos, 
             ylim=ylim, saveto=saveto)


def false_hit_ratio_by_k(DF, limit=1):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  df['ratio'] = (df.tot_hit - df.k) / df.k
  xs[0], ys[0] = gen_xy(df, 'k', 'ratio', limit=limit)
  algos.append('ratio')
  plot_graph('k', 'ratio', list(xs.values()), list(ys.values()), algos, yscale='linear')


def false_hit_by_k(DF, limit=1, saveto=None):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  df['false_hit'] = df.tot_hit - df.k
  xs[0], ys[0] = gen_xy(df, 'k', 'false_hit', limit=limit)
  algos.append(alias['rePolyanya'])
  plot_graph('k', 'false hit', list(xs.values()), list(ys.values()), algos, yscale='linear',
      saveto=saveto)


def maxrank_by_k(DF, limit=1):
  df = DF.copy()
  xs = {}
  ys = {}
  algos = []
  xs[0], ys[0] = gen_xy(df, 'k', 'max_rank', limit=limit)
  algos.append('max_rank')
  plot_graph('k', 'max_rank', list(xs.values()), list(ys.values()), algos, yscale='linear')


def rm_nn_outliers(DF):
  df = DF.copy()
  df1 = df[df.pts == 11]
  df2 = df[df.pts == 110]
  df3 = df[df.pts == 1092]
  df4 = df[df.pts == 10918]

  df1 = df1[df1.cost_fc <= df1.cost_fc.mean() + 2 * df1.cost_fc.std()]
  df2 = df2[df2.cost_fc <= df2.cost_fc.mean() + 2 * df2.cost_fc.std()]
  df3 = df3[df3.cost_fc <= df3.cost_fc.mean() + 2 * df3.cost_fc.std()]
  df4 = df4[df4.cost_fc <= df4.cost_fc.mean() + 2 * df4.cost_fc.std()]
  return pd.concat([df1, df2, df3, df4])

def preprocessing_time(ar0, ar0c, brc, brcc, cat, catc, obs, obsc):
  cols = ['mean', 'std', 'min', '25\%', '50\%', '75\%', 'max']
  data = {
      'AR0602SR': (ar0.cost / 1000.0).describe()[cols],
      'AR0602SR-cluster': (ar0c.cost / 1000.0).describe()[cols],
      'brc202d': (brc.cost / 1000.0).describe()[cols],
      'brc202d-cluster': (brcc.cost / 1000.0).describe()[cols],
      'CatwalkAlley': (cat.cost / 1000.0).describe()[cols],
      'CatwalkAlley-cluster': (catc.cost / 1000.0).describe()[cols],
      '9k-tiled-obs': (obs.cost / 1000.0).describe()[cols],
      '9k-tiled-obs-cluster': (obsc.cost / 1000.0).describe()[cols]
  }
  df = pd.DataFrame.from_dict(data=data, columns=cols, orient='index')
  return df

def preprocessing_label(DF, title="title", saveto=None, ylim=[0, 10]):
  df = DF.copy()
  pts  = sorted(list(set(df.pts.values)))
  density = {pts[0]: '0.01\%', pts[1]: '0.1\%', pts[2]: '1\%', pts[3]: '10\%'}
  df['target density'] = df.pts.apply(lambda x: density[x])
  df = df[df.fencecnt <= df.fencecnt.quantile(0.99)]
  fig, ax = plt.subplots()
  ax.set_ylabel("\#label per edge")
  if ylim is not None:
    ax.set_ylim(ylim)
  df.boxplot(column="fencecnt", by="target density", ax=ax)
  plt.title(title)
  plt.suptitle("")
  if saveto is not None:
    plt.savefig(saveto, bbox_inches="tight")
